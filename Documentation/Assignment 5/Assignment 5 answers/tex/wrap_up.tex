\chapter{Wrap up: Reflection}

`Your journey with Software Engineering Methods is coming to an end: The next iteration will be the final
one. Now take a step back, look at what happened to your source code through the weeks, and reflect on
your practical progress with this course.
Reflect on what you have learned from Software Engineering Methods lab, what you have learned about
yourself as a team of programmers, and how you will use this in the future to design and implement
software systems. To help yourself in this task, you can also consider the first version of your game that
you submitted for evaluation after two weeks and compare it with the version you submit as a final product
for evaluation. Submit an essay of approximately 1,000 words with your reflection'

\section{Essay}
The course Software Engineering Methods of course involved the learning of certain engineering methods, tactics of working in a group, coping with deadlines and because of the latter: planning work in a group. But most of all it was a great experience by doing. By first sprinting in making a game in 2 weeks, and afterwards implementing most of the information heard in lectures, it was a journey of learning by doing. When doing this we of course experienced different bumps in the road, but all of these made us as a group more experienced, efficient and eventually of course made our game better. We will take you through our journey by highlighting a couple aspects:

\subsection{Code quality}
When going back to our initial product, we of course see that the product was lacking features, and was therefore not as much fun to play as it is now. But moreover, we see that our code quality has improved drastically. Implementing for example Design Patterns at first sounded unnecessary, time-consuming and above all irrelevant. However when learning about these patterns and once implementing them, we started to realise this could maybe be useful. Once the design patterns were actually implemented it became obvious that when building on, these design patterns were actually really helpful. They provided a basis for easily adding new features or extending already existing features. Therefore they were in fact very useful in extending and improving our game. It even has been a shame we couldn't implement the design patterns earlier. 

\subsection{Teamwork}
At the start of the project, some of the team members were more experienced than others with working in teams on software projects. So at the start of the project the ones with more experience took the lead in setting up the project. Quickly afterwards however we were all familiar with the workflow. This however didn't mean that Parkinson's Law applied on our project multiple times. A deadline on Friday night often meant a busy Friday night coding. This was however taken into account in every Sprint Reflection, which means that nowadays the work is more evenly spread over the week. Nice benefit is more relaxed Friday nights with an in-time delivery of the game. While advancing through this period we also clearly became more confident in telling each other what the good and especially the bad practices of delivered Pull Requests. This made the team work a lot more efficient than in the beginning of the project. A big benefit above all was that our group included a couple good `managers' who were able to divide all tasks every Tuesday very clearly so that everyone knew what he or she was up to that week. Every team member took the tasks they thought they were good in, or the task with techniques they wanted to learn more about. Good support by other team members always lead to a nice improvement of the game every Friday. 

\subsection{Reviewing}
An important part of our learning process in this subject of course was learning the way code is being reviewed in a game. Most of us were already known with a good GitHub workflow with the reviewing of Pull Requests, but once advancing through this period, the reviewing process speeded up, while it also became more efficient. We all became sharper at the things to look at, and while maybe in the beginning most of the times only the game and tests were run, after a while good code advices and improvements were suggested. This also lead to a better game which, behind the scenes most of time, also ran better and functioned better. Especially when introducing the `Software Metrics', quite interesting aspects and quite important improvements became clear. This definitely fulfilled an important role to show for example the fact that God classes were formed.  

\subsection{Testing}
Although testing is of course an important part of the game, always fully complying with a completely test-driven development still is a hard thing to implement in reality. In theory of course this is the best way to go, but reality learned that it was often more convenient to first write code and afterwards write the tests for the just implemented features. On the other hand we did manage to divide features in small enough parts so that we didn't have to write huge amounts of code and write the belonging tests afterwards. This meant that small parts of code were quickly followed by tests to make sure the feature worked as supposed. \\
Sometimes we did experience that having bigger features, often lead to branches being open for a longer period of time. This on its turn lead to lots of merging conflicts once the feature was submitted as a Pull Request. In the beginning of the project this happened some times, so in the weeks following we tried in our sprints to divide all task in manageable tasks which could be implemented with relative ease and speed. This also meant that the testing was also implemented easier by which the whole test coverage also remained at a steady percentage. 

\subsection{The Future}
All of the above form a solid basis of experience to build our further `Software Engineering'-career on. Design patterns are a piece of theory which proved to be very useful in practice, which we will definitely use in our future projects. Furthermore we learned that software metrics give a good foundation to base application quality on and above all improve software quality. Besides all software engineering aspects we learned, of course every experience in working in a team is a valuable one. Every person functions different in a group and learning what the most efficient way is of communicating with people, is always a useful thing to learn. All together we think the course Software Engineering Methods has been a good mixture between learning theory in lecture, and applying the theory in practice in the labs. Sometimes it's a shame that some theory (as for example UML's) would have already been useful (and also necessary) in the beginning of the course, while the theory only came later on the course. But we definitely learned a lot from this course, so that in the end we will become good Software Engineers! 

