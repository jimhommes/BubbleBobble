\chapter{Wrap up: Reflection}

\section{Essay}
The course Software Engineering Methods involved the learning of engineering methods, tactics of working in a group, coping with deadlines and because of the latter: planning. But most of all it was a great experience, and gave us the chance to learn new Software Engineering Methods. By first being told to make a game within 2 weeks, and afterwards by implementing information heard in lectures, it was a journey of learning by doing. When doing this, we of course experienced different bumps in the road, but all of these made us a better and more experienced group, more efficient and eventually allowed us to made a better game. We will take you through our journey by highlighting a couple aspects:

\subsection{Code quality}
When going back to our initial product, we of course see that the product was lacking features, and was therefore not as much fun to play as it is now. But moreover, we see that our code quality has improved drastically. Implementing for example Design Patterns at first sounded unnecessary, time-consuming and above all irrelevant. However when learning about these patterns and once implementing them, we started to realise that they could be useful. Once the design patterns were actually implemented it became obvious that the code was improving, and that these design patterns were actually really helpful. They provided a basis for easily adding new features or extending already existing features. Therefore they were in fact very useful in extending and improving our game. Looking back, it would have been better if we could have implemented these design patterns earlier, but that is of course all a part of the learning curve. 

\subsection{Teamwork}
At the start of the project, some of the team members were more experienced than others with working in teams on software projects. So at the start of the project the ones with more experience took the lead in setting up the project. However, the others quickly were able to keep up, once familiar with the work flow. This however didn't mean that \fnurl{Parkinson's Law}{https://en.wikipedia.org/wiki/Parkinson\%27s_law} was always applied to our project, especially in the first few sprints. A deadline on Friday night often meant a busy Friday night coding. This was however taken into account in every Sprint Reflection, and we learnt from our mistakes, which means that nowadays the work is more evenly spread over the week. A nice benefit is a more relaxed Friday nights with an in-time delivery of the game. While advancing through this period we also clearly became more confident in telling each other what the good and especially the bad practices of delivered Pull Requests were. This made the team work a lot more efficient than in the beginning of the project. A big benefit above all was that our group included a couple good `managers' who were able to divide all tasks every Tuesday very clearly so that everyone knew what he or she was up to that week. Every team member took the tasks they thought they were good in, or the task with techniques they wanted to learn more about. Good support by other team members always lead to a good improvement of the game every Friday. 

\subsection{Reviewing}
An important part of our learning process in this subject was learning the way code is being reviewed in a game. Not everyone was familiar with a good GitHub work flow, with the reviewing of Pull Requests, but once advancing through this learning period, the reviewing process speeded up, allowing the reviewing to become more efficient. We all became sharper at the things to look at, and while maybe in the beginning some of the times only the game and tests were run, after a while good code advices and improvements were suggested and maven was always run. This also lead to a better game which, behind the scenes also ran better and functioned better. Especially when introducing the `Software Metrics', quite interesting aspects and quite important improvements became clear. This definitely fulfilled an important role to show for example the fact that we had created a few God classes, which needed to change.  

\subsection{Testing}
Although testing is of course an important part of the game, always fully complying with a completely test-driven development still is a hard thing to implement in reality. In theory of course this is the best way to go, but in reality we learned that it was often more convenient to first write code and afterwards write the tests for the just implemented features. On the other hand we did manage to divide features in small enough parts so that we didn't have to write huge amounts of code and write the belonging tests afterwards. This meant that small parts of code were quickly followed by tests to make sure the feature worked as it was supposed to. \\
Sometimes we did experience that having bigger features, often lead to branches being open for a longer period of time. This in its turn led to merge conflicts once the feature was submitted as a Pull Request. In the beginning of the project this happened some times, so in the weeks following we tried in our sprints to divide all task in manageable size tasks which could be implemented with relative ease and speed. This allowed smaller merge conflicts, which were easier to change and control. This also meant that the testing was also implemented easier by which the whole test coverage also remained at a steady percentage. This project also showed us that code needs to be adapted, to allow the code to be tested. At the beginning of the project, there was JavaFX to be be found everywhere. Seeing that JavaFX is very difficult to test, it meant that the test coverage was initially very low. The code was changed, so that JavaFX was only used in certain parts of the code, or called up from a different class, meaning that most of the classes could be tested. This allowed for a huge increase in test coverage. 

\subsection{The Future}
All of the above form a solid basis of experience to build our further `Software Engineering' careers on. Design patterns are a piece of theory which proved to be very useful in both theory and practice, which we will definitely use in our future projects. Furthermore we learned that software metrics give a good foundation to base application quality on and above all improve software quality. Besides all software engineering aspects we learned, of course every experience in working in a team is a valuable one. Every person functions different in a group and learning what the most efficient way is of communicating with people, is always a useful thing to learn. All together we think the course Software Engineering Methods has been a good mixture between learning theory in lecture, and applying the theory in practice in the labs. Sometimes it is a shame that some theory (as for example UML's) would have already been useful (and also necessary) in the beginning of the course, while that theory only came later on the course. But we definitely learned a lot from this course, so that in the end we will become better Software Engineers! 

